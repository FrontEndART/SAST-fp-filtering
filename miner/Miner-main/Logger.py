"""
    This module can log every necessary information to a JSON file.
"""

import json
import shutil
from subprocess import check_output
import threading
import os

current_time = ""
threadsData = {}
report_path = ""
entryStarts = []


def Logger(timestamp, path):
    """
    Setting current time and report path
    :param timestamp: The current time
    :param path: The report path
    """
    global current_time, report_path
    current_time, report_path = timestamp, path + "/"


def add_project(project, threadCount):
    """
    Adding project to mine_attempts dictionary
    :param project: The project
    :param threadCount: The thread number
    """
    threadsData[str(threadCount)]["mine_attempts"]["project"] = project


def add_project_error(project, error):
    """
     Adding a project error to project_error dictionary, and write it out to the JSON
    :param project: The link of the github project
    :param error: The error
    """
    threadsData[threading.current_thread().name]["project_error"]["project"] = project
    threadsData[threading.current_thread().name]["project_error"]["error"] = error
    write_to_file(threadsData[threading.current_thread().name]["project_error"], project.split("/")[-1].split(".")[0], -1)


def add_commit(commit_id, jar_war_ear_zip_files, status, error, tracker):
    """
    Adding a commit to mine_attempts dictionary, and write it out to the JSON
    :param commit_id: The id of the commit
    :param jar_war_ear_zip_files: The files generated by the Maven build
    :param status: The status of the run
    :param error: The error if there is
    :param tracker: The tracker status
    """

    threadsData[threading.currentThread().name]["mine_attempts"]["commit_id"] = commit_id
    threadsData[threading.currentThread().name]["mine_attempts"]["jar_war_ear_zip_files"] = jar_war_ear_zip_files
    threadsData[threading.currentThread().name]["mine_attempts"]["status"] = status
    threadsData[threading.currentThread().name]["mine_attempts"]["error"] = error
    threadsData[threading.currentThread().name]["mine_attempts"]["tracker"] = tracker
    write_to_file(threadsData[threading.currentThread().name]["mine_attempts"], threadsData[threading.currentThread().name]["repo"], -1)


def add_error(project, commit_id, jar_war_ear_zip_files, status, error, tracker):
    """
    Adding an error to mine_attempts dictionary, and write it out to the JSON
    :param project: The link of the github project
    :param commit_id: The id of the commit
    :param jar_war_ear_zip_files: The files generated by the Maven build
    :param status: The error status
    :param error: The error
    :param tracker: The tracker status
    """
    
    threadsData[threading.current_thread().name]["mine_attempts"]["project"] = project
    threadsData[threading.current_thread().name]["mine_attempts"]["commit_id"] = commit_id
    threadsData[threading.current_thread().name]["mine_attempts"]["jar_war_ear_zip_files"] = jar_war_ear_zip_files
    threadsData[threading.current_thread().name]["mine_attempts"]["status"] = status
    threadsData[threading.current_thread().name]["mine_attempts"]["error"] = error
    threadsData[threading.current_thread().name]["mine_attempts"]["tracker"] = tracker
    write_to_file(threadsData[threading.current_thread().name]["mine_attempts"], project.split("/")[-1].split(".")[0], -1)


def add_fix(json, git_dir, repository_name, project, sb_id, base_commit_id, base_file_location, base_location, fix_commit_id, fix_file_location, fix_location, repository_path, warningIDs, entryIDs):
    """
    Adding a fix to fixes dictionary, and write it out to the JSON
    :param git_dir: The git directory
    :param repository_name: The name of the repo we are working with
    :param project: The link of the github project
    :param sb_id: The id of the Spotbugs warning
    :param base_commit_id: The id of the base commit
    :param base_file_location: The file where the warning was
    :param base_location: The location of the warning
    :param fix_commit_id: The id of the fix commit
    :param fix_file_location: The file where the fixing is
    :param fix_location: The location of the fix
    :param repository_path: The path where the repo is
    :param warningIDs: The warning IDs
    :param entryIDs: The list of current entry IDs
    """

    global entryStarts
    if entryStarts == []:
        for i in range(len(warningIDs)):
            entryStarts.append(True)
    entryIDs[warningIDs.index(sb_id)] += 1
    entryID = entryIDs[warningIDs.index(sb_id)]
    threadsData[threading.current_thread().name]["fixes"]["Entry_ID"] = entryID
    threadsData[threading.current_thread().name]["fixes"]["Base"]["Commit_ID"] = base_commit_id
    git_dir.checkout(base_commit_id)
    base_message = check_output(["git", "--git-dir=" + repository_path +
                                "/.git", "log", "--format=%B", "-n", "1"]).decode(encoding="UTF-8")
    base_message = (base_message.rstrip()).replace("\n", "\\n")
    base_message = (base_message.rstrip()).replace("\r", "\\r")
    threadsData[threading.current_thread().name]["fixes"]["Base"]["Message"] = base_message
    base_file = sb_id + "/Files/" + str(entryID) + "/Base/" + base_file_location.rsplit("/", 1)[1]
    threadsData[threading.current_thread().name]["fixes"]["Base"]["Bug_location"][0]["File"] = base_file
    threadsData[threading.current_thread().name]["fixes"]["Base"]["Bug_location"][0]["Locations"] = base_location
    if project.endswith(".git"):
        project = project[:-4]
    base_api_url = "https://api.github.com/repos/" + \
        project.replace("https://github.com/", "") + \
        "/commits/" + base_commit_id
    threadsData[threading.current_thread().name]["fixes"]["Base"]["API_URL"] = base_api_url
    base_html_url = project + "/commit/" + base_commit_id
    threadsData[threading.current_thread().name]["fixes"]["Base"]["HTML_URL"] = base_html_url
    threadsData[threading.current_thread().name]["fixes"]["Fix"]["Commit_ID"] = fix_commit_id
    git_dir.checkout(fix_commit_id)
    fix_message = check_output(["git", "--git-dir=" + repository_path +
                               "/.git", "log", "--format=%B", "-n", "1"]).decode(encoding="UTF-8")
    fix_message = (fix_message.rstrip()).replace("\n", "\\n")
    fix_message = (fix_message.rstrip()).replace("\r", "\\r")
    threadsData[threading.current_thread().name]["fixes"]["Fix"]["Message"] = fix_message
    fix_file = sb_id + "/Files/" + str(entryID) + "/Fix/" + fix_file_location.rsplit("/", 1)[1]
    threadsData[threading.current_thread().name]["fixes"]["Fix"]["Fix_location"][0]["File"] = fix_file
    threadsData[threading.current_thread().name]["fixes"]["Fix"]["Fix_location"][0]["Locations"] = fix_location
    fix_api_url = "https://api.github.com/repos/" + \
        project.replace("https://github.com/", "") + \
        "/commits/" + fix_commit_id
    threadsData[threading.current_thread().name]["fixes"]["Fix"]["API_URL"] = fix_api_url
    fix_html_url = project + "/commit/" + fix_commit_id
    threadsData[threading.current_thread().name]["fixes"]["Fix"]["HTML_URL"] = fix_html_url
    write_to_file(threadsData[threading.current_thread().name]["fixes"], repository_name, warningIDs.index(sb_id), json)
    files_to_dataset(sb_id, entryID, base_commit_id, base_file_location, fix_commit_id, fix_file_location, git_dir, repository_path)


def add_fix_opening(json, warning, warningIDs):
    """
    Adding opening to description JSON files in dataset
    :param json: The JSON file
    :param warning: The warning that belongs to the JSON file
    :param warningIDs: The list of the needed warnings
    """
    sb_name = find_sb_name(warning, warningIDs)
    json.write("{\n    \"Spotbugs_id\": \"" + warning + "\",\n    " +
                "\"Spotbugs_name\": \"" + sb_name + "\",\n    \"Entries\": [")


def files_to_dataset(sb_id, entryID, base_commit_id, base_file, fix_commit_id, fix_file, git_dir, repository_path):
    """
    Adding the base and fix files to dataset
    :param sb_id: The id of the Spotbugs warning
    :param entryID: The ID of current entry
    :param base_commit_id: The id of the base commit
    :param base_file: The file where the warning was
    :param fix_commit_id: The id of the fix commit
    :param fix_file: The file where the fixing is
    :param git_dir: The git directory
    :param repository_path: The path where the repo is
    """
    if not os.path.isdir(report_path + "/dataset" + str(current_time) + "/" + sb_id + "/Files/" + str(entryID)):
        os.mkdir(report_path + "/dataset" + str(current_time) + "/" + sb_id + "/Files/" + str(entryID))
        os.mkdir(report_path + "/dataset" + str(current_time) + "/" + sb_id + "/Files/" + str(entryID) + "/Base")
        os.mkdir(report_path + "/dataset" + str(current_time) + "/" + sb_id + "/Files/" + str(entryID) + "/Fix")
    git_dir.checkout(base_commit_id)
    filePath = base_file.split("/")
    for root, dirs, files in os.walk(repository_path):
        if filePath[0] in dirs:
            base_file = root + "/" + base_file
            break
    shutil.copy2(base_file.strip(), report_path + "/dataset" + str(current_time) + "/" + sb_id + "/Files/" + str(entryID) + "/Base")
    git_dir.checkout(fix_commit_id)
    filePath = fix_file.split("/")
    for root, dirs, files in os.walk(repository_path):
        if filePath[0] in dirs:
            fix_file = root + "/" + fix_file
            break
    shutil.copy2(fix_file.strip(), report_path + "/dataset" + str(current_time) + "/" + sb_id + "/Files/" + str(entryID) + "/Fix")




def find_sb_name(sb_id, warningIDs):
    """
    Returning Spotbugs name from Spotbugs id
    :param sb_id: The Spotbugs id
    :param warningIDs: The warning IDs
    :return: The Spotbugs name
    """

    sb_names = [
        "MS: Field should be package protected ",
        "EI: May expose internal representation by returning reference to mutable object",
        "EI2: May expose internal representation by incorporating reference to mutable object",
        "FI: Finalizer should be protected, not public",
        "MS: Public static method may expose internal representation by returning array",
        "MS: Field is a mutable array",
        "MS: Field is a mutable collection",
        "MS: Field is a mutable collection which should be package protected",
        "MS: Field isn't final but should be",
        "NP: Possible null pointer dereference",
        "NP: Possible null pointer dereference in method on exception path",
        "NP: Method call passes null for non-null parameter",
        "NP: Method call passes null for non-null parameter",
        "NP: Non-virtual method call passes null for non-null parameter",
        "SQL: Nonconstant string passed to execute or addBatch method on an SQL statement",
        "XSS: Servlet reflected cross site scripting vulnerability",
    ]

    for i in range(len(warningIDs)):
        if sb_id == warningIDs[i]:
            return sb_names[i]


def write_to_file(dict, repository_name, warningNum, jsonFile = ""):
    """
    Appending a dictionary to the JSON file
    :param dict: The dictionary
    :param repository_name: The name of the repo we are working with
    :param warningNum: The number of the warning in warning list
    :param jsonFile: The JSON file of logging
    """
    if jsonFile == "": 
        jsonFile = report_path + "mineAttempts_" + repository_name + "_" + str(current_time) + ".json"
    with open(jsonFile, "a") as outfile:
        try:
            global entryStarts
            if threadsData[threading.current_thread().name]["first_write"]:
                json.dump(dict, outfile)
                threadsData[threading.current_thread().name]["first_write"] = False
                return
            elif warningNum != -1 and entryStarts[warningNum] == True:
                json.dump(dict, outfile)
                entryStarts[warningNum] = False
                return
            outfile.write(", ")
            json.dump(dict, outfile)
        except Exception as e:
            print("There is a problem with JSON serialization\nmessage: " + str(e))


def write_opening(repository_name, threadCount):
    """
        Writing starting '[' to JSON file
        :param repository_name: The name of the repo we are working with
        :param threadCount: The thread number
    """
    global threadsData
    if threading.currentThread().name in threadsData:
        threadsData[str(threadCount)]["repo"] = repository_name
        threadsData[str(threadCount)]["first_write"] = True
        threadsData[str(threadCount)]["mine_attempts"] = {"project": "", "commit_id": "", "jar_war_ear_zip_files": [
        ], "status": "", "error": "", "tracker": ""}
        threadsData[str(threadCount)]["project_error"] = {"project": "", "error": ""}
        threadsData[str(threadCount)]["fixes"] = {"Entry_ID": "", "Base": {"Commit_ID": "", "Message": "", "Bug_location": [{"File": "", "Locations": ""}],
                                                                                        "API_URL": "", "HTML_URL": ""}, "Fix": {"Commit_ID": "", "Message": "", "Fix_location": [{"File": "", "Locations": ""}], "API_URL": "", "HTML_URL": ""}}
    else:
        threadsData[str(threadCount)] = {"repo": repository_name, "first_write": True, "fix_counter": 0, "mine_attempts": {"project": "", "commit_id": "", "jar_war_ear_zip_files": [], "status": "", "error": "", "tracker": ""}, "project_error": {"project": "", "error": ""}, "fixes": {
                           "Entry_ID": "", "Base": {"Commit_ID": "", "Message": "", "Bug_location": [{"File": "", "Locations": ""}], "API_URL": "", "HTML_URL": ""}, "Fix": {"Commit_ID": "", "Message": "", "Fix_location": [{"File": "", "Locations": ""}], "API_URL": "", "HTML_URL": ""}}}
    global report_path
    jsonPath = report_path + "mineAttempts_" + repository_name + "_" + str(current_time) + ".json"
    try:
        if not os.path.isfile(jsonPath):
            with open(jsonPath, "a") as outfile:
                outfile.write("[")
    except Exception as e:
        print("There is a problem with JSON serialization\nmessage: " + str(e))


def write_ending(repository_name):
    """
    Writing ending ']' to JSON file
    :param repository_name: The name of the repo we are working with
    """
    with open(report_path + "mineAttempts_" + repository_name + "_" + str(current_time) + ".json", "a") as outfile:
        try:
            outfile.write("]")
        except Exception as e:
            print("There is a problem with JSON serialization\nmessage: " + str(e))

def set_threadsData(thread, key, value):
    try:
        threadsData[str(thread)][key] = value
    except Exception as e:
        print(e)
